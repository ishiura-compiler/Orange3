package Orange3::Generator::Util;

use Math::BigInt;
use Math::BigFloat;

sub reverse_operator {
  my $operator = shift;

  my %reverse = (
    '<'  => '>=',
    '>'  => '<=',
    '<=' => '>',
    '>=' => '<',
    '==' => '!=',
    '!=' => '==',
  );

  return $reverse{$operator};
}

sub int2bits_floor {

  my ($i) = @_;
  my $b = 0;

  while ( 0 < $i ) {
    if ( ( $i & 1 ) == 0 ) { $i--; }
    $b++;
    $i >>= 1;
  }
  return $b;
}

sub get_perl_int_max {

  # $k is it possible integer representation,
  # $k * 2 I ask the $k that integer representation disabled
  my $k;
  for ( $k = 1 ; ( $k * 2 ) !~ /e/ ; $k *= 2 ) {
  }

  # look for an integer that can be represented $m in binary search
  my $lo = $k;
  my $hi = $k * 2;
  for ( ; ; ) {
    my $m = int( ( $lo + $hi ) / 2 );
    if ( $m =~ /e/ ) {
      if ( $hi == $m ) { last; }
      $hi = $m;
    }
    else {
      if ( $lo == $m ) { last; }
      $lo = $m;
    }
  }

  # seek the limit
  my $max = 0;
  for ( $max = $lo ; ( $max + 1 ) !~ /e/ ; $max++ ) {
  }

  return $max;
}

sub get_perl_int_min {

  # $k is it possible integer representation,
  # $k * 2 I ask the $k that integer representation disabled
  my $k;
  for ( $k = -1 ; ( $k * 2 ) !~ /e/ ; $k *= 2 ) {
  }

  # look for an integer that can be represented $m in binary search
  my $lo = $k;
  my $hi = $k * 2;
  for ( ; ; ) {
    my $m = int( ( $lo + $hi ) / 2 );
    if ( $m =~ /e/ ) {
      if ( $hi == $m ) { last; }
      $hi = $m;
    }
    else {
      if ( $lo == $m ) { last; }
      $lo = $m;
    }
  }

  # seek the limit
  my $min = 0;
  for ( $min = $lo ; ( $min - 1 ) !~ /e/ ; $min-- ) {
  }

}

sub random_range {

  #TODO $config;
  my ( $top, $bottom, $type ) = @_;
  my $ans = Math::BigFloat->new(0);
  my ( $si, $ty ) = split( / /, $type, 2 );
  my $max = Math::BigInt->new( $TYPE{$type}->{max} );

  if ( $FLOAT_MODE != 1 ) {
    if ( $type eq "float" || $type eq "double" || $type eq "long double" ) {
      $ans = ( ( $top - $bottom ) * rand() ) + $bottom;

      if ( $type eq "float" ) {
        $ans = sprintf( "%0.5e", $ans );
      }
      elsif ( $type eq "double" ) {
        $ans = sprintf( "%0.15e", $ans );
      }
      elsif ( $type eq "long double" ) {
        $ans = sprintf( "%0.17Le", $ans );
      }
      else { die; }

    }
  }
  else {
    if ( ref $top ne 'Math::BigInt' )    { $top    = Math::BigInt->new($top); }
    if ( ref $bottom ne 'Math::BigInt' ) { $bottom = Math::BigInt->new($top); }
    $ans = Math::BigInt->new(0);
    $ans = $top->as_int()->bsub($bottom);    # top - $bottom + 1;
    my $rand = Math::BigFloat->new( rand() );
    $rand = $rand->copy()->bmul($ans)->ffround(0)->bstr()
      ;    # rand * $ans , Integer and rounds to a point below 0 direction
    $rand = Math::BigInt->new($rand);
    $ans  = $rand->as_int()->badd($bottom);    # rand + $bottom

    unless ( $bottom <= $ans && $ans <= $top ) {
      die "$bottom < $ans < $top\n";
    }
  }

  #	print "$bottom < $ans < $top\n";
  if ( $ans eq 'NaN'
    || $ans eq 'nan'
    ) # NaN is I've been avoiding because generated by that accidentally get a few rare cases very small in rand
  {
    print "Nan is occured.\n" if (DEBUG_MODE);
    $ans = $bottom;    # Interim
    if ( $bottom eq 'NaN'
      || $top eq 'NaN'
      || $bottom eq 'nan'
      || $top eq 'nan'
      || $bottom eq 'inf'
      || $top eq 'inf' )
    {
      $ans = 0;
    }
  }
  elsif ( $ans eq 'inf' ) {
    print "inf is occured.\n" if (DEBUG_MODE);
    $ans = 0;
  }
  else { ; }

  if ( $si eq "unsigned" ) {
    $ans = ( $ans % ( $max + 1 ) );
  }

  return $ans;
}
1;
